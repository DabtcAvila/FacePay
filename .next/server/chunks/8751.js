"use strict";exports.id=8751,exports.ids=[8751],exports.modules={48576:(e,t,r)=>{r.d(t,{c_:()=>l,ow:()=>c,q6:()=>o});var a=r(6113),i=r.n(a);let n=process.env.ENCRYPTION_KEY||"your-32-byte-encryption-key-here",s="aes-256-gcm";function o(e){let t=i().randomBytes(12),r=i().createCipheriv(s,Buffer.from(n,"utf8").subarray(0,32),t),a=r.update(e,"utf8","hex");a+=r.final("hex");let o=r.getAuthTag();return{encrypted:a,iv:t.toString("hex"),tag:o.toString("hex")}}function c(e){let t=Buffer.from(e.iv,"hex"),r=i().createDecipheriv(s,Buffer.from(n,"utf8").subarray(0,32),t);return r.setAuthTag(Buffer.from(e.tag,"hex")),r.update(e.encrypted,"hex","utf8")+r.final("utf8")}function l(e){return new Promise((t,a)=>{r(42023).hash(e,12,(e,r)=>{e?a(e):t(r)})})}},13538:(e,t,r)=>{r.d(t,{_:()=>n});var a=r(53524);let i=globalThis,n=i.prisma??=new a.PrismaClient({log:["query"]})},48751:(e,t,r)=>{r.r(t),r.d(t,{DEFAULT_CONFIG:()=>o,FaceVerificationService:()=>c,createFaceVerificationService:()=>d,faceVerificationService:()=>l});var a=r(6113),i=r.n(a),n=r(13538),s=r(48576);let o={confidenceThreshold:.85,maxAttempts:5,attemptWindowMinutes:15,enableLogging:!0,qualityThreshold:.7,antiSpoofingEnabled:!0};class c{constructor(e={}){this.config={...o,...e}}async enrollFace(e,t,r=!1){let a=Date.now();try{let i=await this.validateImage(t);if(!i.valid)return{success:!1,embeddingId:"",quality:0,message:i.error||"Invalid image format"};let n=await this.extractFaceEmbedding(t);if(!n)return{success:!1,embeddingId:"",quality:0,message:"No face detected in image or poor quality"};if(n.quality<this.config.qualityThreshold)return{success:!1,embeddingId:"",quality:n.quality,message:"Image quality too low for enrollment"};if(r)await this.deactivateUserEmbeddings(e);else if(await this.getActiveEmbeddingCount(e)>0)return{success:!1,embeddingId:"",quality:n.quality,message:"User already has enrolled face data"};let s=await this.storeEncryptedEmbedding(e,n),o=Date.now()-a;return this.config.enableLogging&&await this.logEnrollment(e,s,n.quality),{success:!0,embeddingId:s,quality:n.quality,message:"Face enrolled successfully",metadata:{processingTime:o,imageQuality:n.quality}}}catch(e){return console.error("Face enrollment error:",e),{success:!1,embeddingId:"",quality:0,message:"Internal error during enrollment"}}}async verifyFace(e,t,r){let a=Date.now(),n=i().randomUUID();try{let i=await this.checkRateLimit(r?.ipAddress);if(!i.allowed)return{success:!1,confidence:0,attemptId:n,riskScore:1,message:"Too many verification attempts. Please try again later."};let s=await this.validateImage(e);if(!s.valid)return{success:!1,confidence:0,attemptId:n,riskScore:.8,message:s.error||"Invalid image"};let o=await this.extractFaceEmbedding(e);if(!o)return{success:!1,confidence:0,attemptId:n,riskScore:.7,message:"No face detected or poor image quality"};let c=await this.performAntiSpoofingCheck(e);if(!c.passed)return await this.logVerificationAttempt({id:n,userId:"",timestamp:new Date,success:!1,confidence:0,ipAddress:r?.ipAddress,userAgent:r?.userAgent,riskScore:.9}),{success:!1,confidence:0,attemptId:n,riskScore:.9,message:"Suspected spoofing attempt detected",metadata:{processingTime:Date.now()-a,qualityScore:o.quality,antiSpoofingPassed:!1}};let l=await this.getStoredEmbeddings(t);if(0===l.length)return{success:!1,confidence:0,attemptId:n,riskScore:.3,message:"No enrolled face data found"};let d=null;for(let e of l){let t=await this.calculateSimilarity(o,e.embedding);t>=this.config.confidenceThreshold&&(!d||t>d.similarity)&&(d={similarity:t,userId:e.userId})}let u=null!==d,g=d?.similarity||0,m=this.calculateRiskScore(g,c,i);return this.config.enableLogging&&await this.logVerificationAttempt({id:n,userId:d?.userId||"",timestamp:new Date,success:u,confidence:g,ipAddress:r?.ipAddress,userAgent:r?.userAgent,riskScore:m}),{success:u,confidence:g,userId:u?d.userId:void 0,attemptId:n,riskScore:m,message:u?"Face verified successfully":"Face verification failed",metadata:{processingTime:Date.now()-a,qualityScore:o.quality,antiSpoofingPassed:c.passed}}}catch(e){return console.error("Face verification error:",e),{success:!1,confidence:0,attemptId:n,riskScore:1,message:"Internal error during verification"}}}async extractFaceEmbedding(e){try{let t="string"==typeof e?Buffer.from(e.replace(/^data:image\/[a-z]+;base64,/,""),"base64"):e,r=i().createHash("sha256").update(t).digest("hex");if(!(t.length>1e3))return null;let a=this.generateSimulatedEmbedding(r),n=this.calculateImageQuality(t);return{vector:a,quality:n,confidence:.95,metadata:{extractedAt:new Date().toISOString(),imageHash:r,dimensions:{width:224,height:224}}}}catch(e){return console.error("Face embedding extraction error:",e),null}}async calculateSimilarity(e,t){try{let r=e.vector,a=t.vector;if(r.length!==a.length)throw Error("Embedding dimensions do not match");let i=0,n=0,s=0;for(let e=0;e<r.length;e++)i+=r[e]*a[e],n+=r[e]*r[e],s+=a[e]*a[e];if(n=Math.sqrt(n),s=Math.sqrt(s),0===n||0===s)return 0;return(i/(n*s)+1)/2}catch(e){return console.error("Similarity calculation error:",e),0}}async encryptEmbedding(e){try{let t=JSON.stringify(e),r=(0,s.q6)(t);return JSON.stringify(r)}catch(e){throw console.error("Embedding encryption error:",e),Error("Failed to encrypt face embedding")}}async decryptEmbedding(e){try{let t=JSON.parse(e),r=(0,s.ow)(t);return JSON.parse(r)}catch(e){throw console.error("Embedding decryption error:",e),Error("Failed to decrypt face embedding")}}async storeEncryptedEmbedding(e,t){let r=await this.encryptEmbedding(t);return(await n._.biometricData.create({data:{userId:e,type:"face",data:r,isActive:!0}})).id}async getStoredEmbeddings(e){let t=await n._.biometricData.findMany({where:e?{id:e,type:"face",isActive:!0}:{type:"face",isActive:!0},select:{userId:!0,data:!0}}),r=[];for(let e of t)try{let t=await this.decryptEmbedding(e.data);r.push({userId:e.userId,embedding:t})}catch(t){console.error("Failed to decrypt embedding for user:",e.userId,t)}return r}async validateImage(e){try{let t="string"==typeof e?Buffer.from(e.replace(/^data:image\/[a-z]+;base64,/,""),"base64"):e;if(t.length<1e3)return{valid:!1,error:"Image too small"};if(t.length>10485760)return{valid:!1,error:"Image too large"};let r=t.subarray(0,4),a=255===r[0]&&216===r[1],i=137===r[0]&&80===r[1]&&78===r[2]&&71===r[3];if(!a&&!i)return{valid:!1,error:"Unsupported image format. Use JPEG or PNG."};return{valid:!0}}catch(e){return{valid:!1,error:"Invalid image data"}}}async performAntiSpoofingCheck(e){if(!this.config.antiSpoofingEnabled)return{passed:!0,confidence:1};try{let t="string"==typeof e?Buffer.from(e.replace(/^data:image\/[a-z]+;base64,/,""),"base64"):e,r=this.detectCompressionArtifacts(t),a=this.analyzeColorDistribution(t),i=.5;return r&&(i+=.3),a&&(i+=.2),{passed:i>=.7,confidence:i}}catch(e){return console.error("Anti-spoofing check error:",e),{passed:!0,confidence:.5}}}async checkRateLimit(e){if(!e)return{allowed:!0,remainingAttempts:this.config.maxAttempts};let t=new Date(Date.now()-6e4*this.config.attemptWindowMinutes),r=await this.getRecentAttempts(e,t),a=Math.max(0,this.config.maxAttempts-r);return{allowed:a>0,remainingAttempts:a}}calculateRiskScore(e,t,r){let a=0;return e<this.config.confidenceThreshold&&(a+=.4),t.passed?t.confidence<.8&&(a+=.2):a+=.4,r.allowed?r.remainingAttempts<2&&(a+=.1):a+=.3,Math.min(1,a)}generateSimulatedEmbedding(e){let t=[],r=parseInt(e.substring(0,8),16);for(let e=0;e<512;e++)t.push(((r=(9301*r+49297)%233280)/233280-.5)*2);return t}calculateImageQuality(e){let t=e.length,r=this.calculateEntropy(e.subarray(0,Math.min(1024,e.length))),a=.5;return t>5e4&&(a+=.2),t>1e5&&(a+=.1),Math.min(1,a+=Math.min(.3,r/8*.3))}calculateEntropy(e){let t=Array(256).fill(0);for(let r=0;r<e.length;r++)t[e[r]]++;let r=0;for(let a of t)if(a>0){let t=a/e.length;r-=t*Math.log2(t)}return r}detectCompressionArtifacts(e){for(let t=0;t<e.length-1;t++)if(255===e[t]&&(192===e[t+1]||194===e[t+1]))return!0;return!1}analyzeColorDistribution(e){let t=e.subarray(100,Math.min(1100,e.length));return new Set(t).size>.3*t.length}async deactivateUserEmbeddings(e){await n._.biometricData.updateMany({where:{userId:e,type:"face",isActive:!0},data:{isActive:!1}})}async getActiveEmbeddingCount(e){return n._.biometricData.count({where:{userId:e,type:"face",isActive:!0}})}async logEnrollment(e,t,r){console.log("Face enrollment:",{userId:e,embeddingId:t,quality:r,timestamp:new Date})}async logVerificationAttempt(e){console.log("Face verification attempt:",e)}async getRecentAttempts(e,t){return Math.floor(3*Math.random())}}let l=new c;function d(e){return new c(e)}}};